<!doctype html><html lang='en'><head><title>VSTPlugin | SuperCollider 3.11.0 Help</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../codemirror.css' type='text/css' />
<link rel='stylesheet' href='./../editor.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../lib/jquery.min.js'></script>
<script src='./../lib/codemirror-5.39.2.min.js' type='text/javascript'></script>
<script src='./../lib/codemirror-addon-simple-5.39.2.min.js' type='text/javascript'></script>
<script>
var helpRoot = './..';
var scdoc_title = 'VSTPlugin';
var scdoc_sc_version = '3.11.0';
</script>
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='qrc:///qtwebchannel/qwebchannel.js' type='text/javascript'></script>
</head>
<body onload='fixTOC()'>
<div id='toc'>
<div id='toctitle'>VSTPlugin:</div>
<span class='toc_search'>Filter: <input id='toc_search'></span><ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*ar'>ar</a> </li>
<li class='toc2'><a href='#Plugin%20Management'>Plugin Management</a></li>
<ul class='toc'><li class='toc3'><a href='#*plugins'>plugins</a> </li>
<li class='toc3'><a href='#*pluginList'>pluginList</a> </li>
<li class='toc3'><a href='#*pluginKeys'>pluginKeys</a> </li>
<li class='toc3'><a href='#*print'>print</a> </li>
</ul><li class='toc2'><a href='#Searching%20for%20plugins'>Searching for plugins</a></li>
<ul class='toc'><li class='toc3'><a href='#*search'>search</a> </li>
<li class='toc3'><a href='#*searchMsg'>searchMsg</a> </li>
<li class='toc3'><a href='#*stopSearch'>stopSearch</a> </li>
<li class='toc3'><a href='#*stopSearchMsg'>stopSearchMsg</a> </li>
<li class='toc3'><a href='#*probe'>probe</a> </li>
<li class='toc3'><a href='#*probeMsg'>probeMsg</a> </li>
<li class='toc3'><a href='#*readPlugins'>readPlugins</a> </li>
<li class='toc3'><a href='#*clear'>clear</a> </li>
<li class='toc3'><a href='#*clearMsg'>clearMsg</a> </li>
</ul><li class='toc2'><a href='#Inherited%20class%20methods'>Inherited class methods</a></li>
<li class='toc2'><a href='#Undocumented%20class%20methods'>Undocumented class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*versionBugfix'>versionBugfix</a> </li>
<li class='toc3'><a href='#*versionMajor'>versionMajor</a> </li>
<li class='toc3'><a href='#*versionMinor'>versionMinor</a> </li>
</ul></ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-id'>id</a> </li>
<li class='toc2'><a href='#Inherited%20instance%20methods'>Inherited instance methods</a></li>
<li class='toc2'><a href='#Undocumented%20instance%20methods'>Undocumented instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-info'>info</a> </li>
</ul></ul></ul></div><div id='menubar'></div>
<div class='contents'>
<div class='header'>
<div id='label'>
<span id='folder'>Classes (extension)</span>
 | <span id='categories'><a href='./..\Browse.html#UGens'>UGens</a>&#8201;&gt;&#8201;<a href='./..\Browse.html#UGens>FX'>FX</a></span>
</div><h1>VSTPlugin<span id='superclasses'> : <a href="../Classes/MultiOutUGen.html">MultiOutUGen</a> : <a href="../Classes/UGen.html">UGen</a> : <a href="../Classes/AbstractFunction.html">AbstractFunction</a> : <a href="../Classes/Object.html">Object</a></span>
<div class='extension-indicator-ctr' title='This help file originates from a third-party quark or plugin for SuperCollider.'><img class='extension-indicator-icon' alt='Extension' src='./../images/plugin.png'><span class='extension-indicator-text'>Extension</span></div></h1>
<div id='summary'>load VST plugins as UGens</div>
</div>
<div class='subheader'>
<div id='filename'>Source: <a href='file:///C:/Users/Christof/AppData/Local/SuperCollider/Extensions/VSTPlugin/classes/VSTPlugin.sc' title='C:\Users\Christof\AppData\Local\SuperCollider\Extensions\VSTPlugin\classes\VSTPlugin.sc'>VSTPlugin.sc</a></div><div id='related'>See also: <a href="./..\Classes/VSTPluginController.html">VSTPluginController</a>, <a href="./..\Classes/VSTPluginDesc.html">VSTPluginDesc</a>, <a href="./..\Classes/VSTPluginGui.html">VSTPluginGui</a>, <a href="./..\Guides/HOA_IEM.html">High order ambisonics using IEM Plugins</a>, <a href="./..\Reference/VSTPlugin-UGen-Documentation.html">VSTPlugin - UGen documentation</a></div>
</div>
<h2><a class='anchor' name='description'>Description</a></h2>

<p>This UGen represents a single VST plugin instance on the <a href="./..\Classes/Server.html">Server</a>. See the helpfile of <a href="./..\Classes/VSTPluginController.html">VSTPluginController</a> for how to control it from the SuperCollider language.
<p>VSTPlugin also has class methods to scan a Server for plugins and cache the info in the Client, see <a href="#Plugin%20Management">Plugin Management</a>.<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*ar' href='./../Overviews/Methods.html#ar'>ar</a>(<span class='argstr'>input</span>, <span class='argstr'>numOut: 1</span>, <span class='argstr'>bypass: 0</span>, <span class='argstr'>params</span>, <span class='argstr'>id</span>, <span class='argstr'>info</span>, <span class='argstr'>auxInput</span>, <span class='argstr'>numAuxOut: 0</span>)</h3>
<div class='method'>
<p>create a UGen instance.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>input<td class='argumentdesc'>
<p>An Array of channels or single input for the plugin to process. You cannot change the size of this once a SynthDef has been built. Set this to <code>nil</code> if the plugin takes no audio input (e.g. software synthesizers).<tr><td class='argumentname'>numOut<td class='argumentdesc'>
<p>The number of output channels. This must be a fixed number greater than 0.<tr><td class='argumentname'>bypass<td class='argumentdesc'>
<p>change the bypass state. If bypass is non-zero, then processing is suspended and each input is passed straight to its corresponding output.<table>
<tr><td>0<td>off (processing)<tr><td>1<td>hard bypass; processing is suspended immediately and the plugin's own bypass method is called (if available). Good plugins will do a short crossfade, others will cause a click.<tr><td>2<td>soft bypass; if the plugin has a tail (e.g. reverb or delay), it will fade out. This doesn't call the plugin's bypass method, so we can always do a nice crossfade.</table>
<tr><td class='argumentname'>params<td class='argumentdesc'>
<p>An optional Array of parameter controls in pairs of index and value. Both can be automated.<textarea class='editor'>// 'p1' controls parameter 1.
// 'p2' controls a parameter whose index can be set dynamically with 'idx'.
SynthDef(\test, { arg in, p1, p2, idx;
    var sig = VSTPlugin.ar(In.ar(in, 2), 1,
        params: [1, p1, idx, p2]);
    Out.ar(0, sig);
});</textarea>

<p>You can set the index to a negative value to "unmap" the parameter.<div class='note'><span class='notelabel'>NOTE:</span> <em>params</em> overrides any automation of the same parameters by <a href="./..\Classes/VSTPluginController.html#-set">VSTPluginController: -set</a>, but it can itself be overriden with <a href="./..\Classes/VSTPluginController.html#-map">VSTPluginController: -map</a>.</div>
<p>You can automate parameters with either control and audio rate UGens, but the latter is more CPU expensive and only makes sense if the plugin actually supports sample accurate automation (some, but not all VST3 plugins).<tr><td class='argumentname'>id<td class='argumentdesc'>
<p>An optional number or symbol which uniquely identifies the UGen within a SynthDef so it can be found by <a href="./..\Classes/VSTPluginController.html">VSTPluginController</a>. This is only necessary if there is more than one VSTPlugin instance in the SynthDef!<textarea class='editor'>(
// an EQ and Chorus in parallel:
SynthDef(\test, { arg in, out;
    var sig;
    sig = VSTPlugin.ar(In.ar(in, 2), 2, id: \eq);
    sig = VSTPlugin.ar(sig, 2, id: \chorus);
    Out.ar(out, sig);
}).add;
)
~synth = Synth(\test, [\in, ~in, \out, ~out]);
(
// this is how you get a handle to a specific plugin instance in the Synth:
~eq = VSTPluginController.new(~synth, \eq);
~chorus = VSTPluginController.new(~synth, \chorus);
)
// load plugins, etc:
~eq.open("...");
~chorus.open("...");</textarea>
<tr><td class='argumentname'>info<td class='argumentdesc'>
<p>An optional <a href="./..\Classes/VSTPluginDesc.html">VSTPluginDesc</a> instance; the plugin must have been successfully probed (e.g. with <a href="./..\Classes/VSTPlugin.html#*search">VSTPlugin: *search</a>).
<p>If you know in advance which VST plugin you want to load, this allows you to use parameter names instead of indices<textarea class='editor'>(
SynthDef(\chorus, { arg bus;
    var plugin = VSTPlugin.plugins['GChorus'];
    var sig = VSTPlugin.ar(In.ar(bus, 2), 2, params: [Depth: 0.5, Mix: 0.9], info: plugin);
    ReplaceOut.ar(bus, sig);
}).add;
)</textarea>

<p>Also, you can omit the <code>path</code> argument when opening plugins:<textarea class='editor'>~fx = VSTPluginController(Synth(\chorus)).open; // will open 'GChorus'</textarea>
<tr><td class='argumentname'>auxInput<td class='argumentdesc'>
<p>An Array of channels or a single auxiliary input for the plugin to process. You cannot change the size of this once a SynthDef has been built. This is only useful for certain VST3 plugins (e.g. for side chaining).<tr><td class='argumentname'>numAuxOut<td class='argumentdesc'>
<p>The number of auxiliary output channels. This must be a fixed number greater or equal 0. Like <code>auxInput</code>, this is only useful for certain VST3 plugins.</table></div><h3><a class='anchor' name='Plugin%20Management'>Plugin Management</a></h3>

<p>All VST plugin information is cached in the Client. This is done mainly for performance reasons but it can be also handy for end users because it's possible to investigate plugins without actually creating any instances.
<p>The plugin info is stored as a <a href="./..\Classes/VSTPluginDesc.html">VSTPluginDesc</a> instance under its key (see <a href="./..\Classes/VSTPluginDesc.html#-key">VSTPluginDesc: -key</a>) and can be retrieved with <a href="#*plugins">*plugins</a>.<h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*plugins' href='./../Overviews/Methods.html#plugins'>plugins</a>(<span class='argstr'>server</span>)</h3>
<div class='method'>
<p>get information about (probed) VST plugins on a Server.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>the Server. If this is <code>nil</code>, the default Server is assumed.</table><h4>Returns:</h4>
<div class='returnvalue'>
<p>an <a href="./..\Classes/IdentityDictionary.html">IdentityDictionary</a> containing the descriptions of all VST plugins on the Server as instances of <a href="./..\Classes/VSTPluginDesc.html">VSTPluginDesc</a>.</div><h4>Discussion:</h4>

<p>The dictionary can be simply indexed with plugin keys (see <a href="./..\Classes/VSTPluginDesc.html#-key">VSTPluginDesc: -key</a>).<textarea class='editor'>// search in default paths
VSTPlugin.search(s);
VSTPlugin.plugins(s)['AwesomePlugin'].print;
// for the default server this can be shortend to:
VSTPlugin.search;
VSTPlugin.plugins['AwesomePlugin'].print;</textarea>
</div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*pluginList' href='./../Overviews/Methods.html#pluginList'>pluginList</a>(<span class='argstr'>server</span>, <span class='argstr'>sorted: false</span>)</h3>
<div class='method'>
<p>get all available plugins on a Server.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>the Server. If <code>nil</code>, the default Server is assumed.<tr><td class='argumentname'>sorted<td class='argumentdesc'>
<p>whether the Array should be sorted alphabetically (by name).</table><h4>Returns:</h4>
<div class='returnvalue'>
<p>an Array of <a href="./..\Classes/VSTPluginDesc.html">VSTPluginDesc</a> instances.</div></div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*pluginKeys' href='./../Overviews/Methods.html#pluginKeys'>pluginKeys</a>(<span class='argstr'>server</span>)</h3>
<div class='method'>
<p>get the keys of all plugins on a given Server.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>the Server. If <code>nil</code>, the default Server is assumed.</table><h4>Returns:</h4>
<div class='returnvalue'>
<p>an Array of plugin keys.</div><h4>Discussion:</h4>

<p>This method only considers the keys stored in the plugin descriptions, not the additional keys in the plugin dictionary.</div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*print' href='./../Overviews/Methods.html#print'>print</a>(<span class='argstr'>server</span>)</h3>
<div class='method'>
<p>post all available plugins.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>the Server. If <code>nil</code>, the default Server is assumed.</table><h4>Discussion:</h4>

<p>The plugins are posted in alphabetical order in the following format:
<p><code>key (vendor) [path]</code></div><h3><a class='anchor' name='Searching%20for%20plugins'>Searching for plugins</a></h3>
<h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*search' href='./../Overviews/Methods.html#search'>search</a>(<span class='argstr'>server</span>, <span class='argstr'>dir</span>, <span class='argstr'>useDefault: true</span>, <span class='argstr'>verbose: true</span>, <span class='argstr'>wait: -1</span>, <span class='argstr'>action</span>, <span class='argstr'>save: true</span>, <span class='argstr'>parallel: true</span>)</h3>
<div class='method'>
<p>Scan a local or remote Server for VST plugins and cache the info in the Client.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server to scan for plugins. If the argument is <code>nil</code>, the default Server is used.<tr><td class='argumentname'>dir<td class='argumentdesc'>
<p>An optional Array of directories to search.<tr><td class='argumentname'>useDefault<td class='argumentdesc'>
<p>Whether to search in the default paths, which currently are:<table>
<tr><td>VST 2.x<td><table>
<tr><td>Windows<td><ul>
<li>%ProgramFiles%\VSTPlugins<li>%ProgramFiles%\Steinberg\VSTPlugins<li>%ProgramFiles%\Common Files\VST2<li>%ProgramFiles%\Common Files\Steinberg\VST2</ul>

<p><tr><td>macOS<td><ul>
<li>~/Library/Audio/Plug-Ins/VST<li>/Library/Audio/Plug-Ins/VST</ul>

<p><tr><td>Linux<td><ul>
<li>~/.vst<li>/usr/local/lib/vst<li>/usr/lib/vst</ul>
</table>

<p><tr><td>VST 3.x<td><table>
<tr><td>Windows<td><ul>
<li>%ProgramFiles%\Common Files\VST3</ul>

<p><tr><td>macOS<td><ul>
<li>~/Library/Audio/Plug-Ins/VST3<li>/Library/Audio/Plug-Ins/VST3</ul>

<p><tr><td>Linux<td><ul>
<li>~/.vst3<li>/usr/local/lib/vst3<li>/usr/lib/vst3</ul>
</table>
</table>
<div class='note'><span class='notelabel'>NOTE:</span> here, <em>%ProgramFiles%</em> stands for "C:\Program Files" on a 64 bit Server and "C:\Program Files (x86)" on a 32 bit Server.</div><tr><td class='argumentname'>verbose<td class='argumentdesc'>
<p>a Boolean telling if the Server should post a message for each VST plugin being found.
<p>The message shows the file path, name and probe result. Probing can fail if the file is not a VST plugin or if it has the wrong architecture (64 bit vs. 32 bit).<tr><td class='argumentname'>wait<td class='argumentdesc'>
<p>The wait time between OSC messages.
<p>-1 allows an OSC roundtrip between packets.
<p>0 is not safe with UDP, but is probably ok with TCP.<div class='note'><span class='notelabel'>NOTE:</span> This is only relevant for remote Servers (local Servers will send the plugin description via temp files).</div><tr><td class='argumentname'>action<td class='argumentdesc'>
<p>an action to be called after the search has finished.<tr><td class='argumentname'>save<td class='argumentdesc'>
<p>whether the search results should be written to the cache file.<tr><td class='argumentname'>parallel<td class='argumentdesc'>
<p>whether plugins should be probed in parallel. This can be significantly faster - at the cost of possible audio dropouts (because all CPU cores might be fully utilized).<div class='note'><span class='notelabel'>NOTE:</span> Shell plugins like "Waves" are always probed in parallel for performance reasons.</div></table><h4>Discussion:</h4>

<p>Directories are searched recursively. For each valid VST plugin, the information is stored in a dictionary on the Client and can be retrieved with its key (see <a href="#Plugin%20Management">Plugin Management</a>).
<p>If a plugin can't be probed ("... failed!") it either means it's not a valid VST plugin, dependencies are missing or it has the wrong architecture.<div class='note'><span class='notelabel'>NOTE:</span> Generally, you can't use 32 bit plugins on a 64 bit Server and vice verca!</div>
<p>A new search doesn't automatically clear the dictionary, but existing keys are overwritten. You can clear the dictionary explicitly with <a href="#*clear">*clear</a>.
<p>For efficiency, search results are written to a cache file (on the Server's computer) to significantly speed up subsequent searches (cached plugins don't have to probed again). Many DAWs use a similar strategy. If you want to search directories without updating the cache, set <code>save</code> to <code>false</code>.<div class='note'><span class='notelabel'>NOTE:</span> The very first search in a directory usually takes a couple of seconds, but if you have many (heavy) plugins, the process can take significantly longer. However, subsequent searches will be almost instantaneous (because of the cache file).</div><div class='warning'><span class='warninglabel'>WARNING:</span> Shell plugins like "Waves" contain hundreds of (heavy) sub-plugins. On my machine, the very first search takes several minutes(!), so be patient :-)</div></div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*searchMsg' href='./../Overviews/Methods.html#searchMsg'>searchMsg</a>(<span class='argstr'>dir</span>, <span class='argstr'>useDefault: true</span>, <span class='argstr'>verbose: false</span>, <span class='argstr'>save: true</span>, <span class='argstr'>parallel: true</span>, <span class='argstr'>dest</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>dir<td class='argumentdesc'>
<p>(see above)<tr><td class='argumentname'>useDefault<td class='argumentdesc'>
<p>(see above)<tr><td class='argumentname'>verbose<td class='argumentdesc'>
<p>(see above)<tr><td class='argumentname'>save<td class='argumentdesc'>
<p>(see above)<tr><td class='argumentname'>parallel<td class='argumentdesc'>
<p>(see above)<tr><td class='argumentname'>dest<td class='argumentdesc'>
<p>a) nil: don't write search results (the default)
<p>a) String: name of a temp file where the search results should be written to.
<p>b) <a href="./..\Classes/Buffer.html">Buffer</a> or bufnum: the plugin will fill the Buffer on the Server, the Client can then read the data (each float representing a single byte) and free the Buffer. The Buffer should be initially empty!</table><h4>Returns:</h4>
<div class='returnvalue'>
<p>the message for a <em>search</em> command (see <a href="#*search">*search</a>).</div><h4>Discussion:</h4>

<p>Sending the message to the Server will <em>not</em> update any info in the Client! Useful for NRT synthesis.</div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*stopSearch' href='./../Overviews/Methods.html#stopSearch'>stopSearch</a>(<span class='argstr'>server</span>)</h3>
<div class='method'>
<p>Stop a running search.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>the Server. If <code>nil</code>, the default Server is assumed.</table></div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*stopSearchMsg' href='./../Overviews/Methods.html#stopSearchMsg'>stopSearchMsg</a></h3>
<div class='method'>
<p><h4>Returns:</h4>
<div class='returnvalue'>
<p>the message for a <em>stopSearch</em> command (see <a href="#*stopSearch">*stopSearch</a>).</div></div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*probe' href='./../Overviews/Methods.html#probe'>probe</a>(<span class='argstr'>server</span>, <span class='argstr'>path</span>, <span class='argstr'>key</span>, <span class='argstr'>wait: -1</span>, <span class='argstr'>action</span>)</h3>
<div class='method'>
<p>Probe a single VST plugin.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>the Server. If <code>nil</code>, the default Server is assumed.<tr><td class='argumentname'>path<td class='argumentdesc'>
<p>the plugin file path.<tr><td class='argumentname'>key<td class='argumentdesc'>
<p>an (optional) additional key under which the plugin description is stored.<tr><td class='argumentname'>wait<td class='argumentdesc'>
<p>the wait time, see <a href="#*search">*search</a>.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>an action to be evaluated after the search has finished. On success, a <a href="./..\Classes/VSTPluginDesc.html">VSTPluginDesc</a> instances is passed, otherwise the argument is <code>nil</code>.</table><h4>Discussion:</h4>

<p>The given plugin file path is probed on the Server (in a seperate process). On success, the plugin description is stored under its key, the file path and the (optional) key argument.
<p>This method is used internally by <a href="./..\Classes/VSTPluginController.html#-open">VSTPluginController: -open</a> whenever it can't find a key in the plugin dictionary. It might be occasionally useful for other purposes.</div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*probeMsg' href='./../Overviews/Methods.html#probeMsg'>probeMsg</a>(<span class='argstr'>path</span>, <span class='argstr'>dest</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>path<td class='argumentdesc'>
<p>the plugin path (see above)<tr><td class='argumentname'>dest<td class='argumentdesc'>
<p>a) nil: don't write probe result (the default)
<p>a) String: name of a temp file where the probe result should be written to.
<p>b) <a href="./..\Classes/Buffer.html">Buffer</a> or bufnum: the plugin will fill the Buffer on the Server, the Client can then read the data (each float representing a single byte) and free the Buffer. The Buffer should be initially empty!</table><h4>Returns:</h4>
<div class='returnvalue'>
<p>the message for a <em>probe</em> command (see <a href="#*probe">*probe</a>).</div><h4>Discussion:</h4>

<p>Sending this message to the Server will <em>not</em> update any info in the Client!</div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*readPlugins' href='./../Overviews/Methods.html#readPlugins'>readPlugins</a></h3>
<div class='method'>
<p>get the descriptions of all locally cached plugins. For this to work, you have to call <a href="#*search">*search</a> at least once (with <code>save: true</code>), then the plugin description will be available without starting a Server.<h4>Returns:</h4>
<div class='returnvalue'>
<p>an <a href="./..\Classes/IdentityDictionary.html">IdentityDictionary</a> containing all plugin descriptions as <a href="./..\Classes/VSTPluginDesc.html">VSTPluginDesc</a> instances.</div></div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*clear' href='./../Overviews/Methods.html#clear'>clear</a>(<span class='argstr'>server</span>, <span class='argstr'>remove: true</span>)</h3>
<div class='method'>
<p>Deletes all cached plugin descriptions for a given Server.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>the Server. If this is <code>nil</code>, the default Server is assumed.<tr><td class='argumentname'>remove<td class='argumentdesc'>
<p>whether you want to also remove the cache file.</table></div><h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*clearMsg' href='./../Overviews/Methods.html#clearMsg'>clearMsg</a>(<span class='argstr'>remove: true</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>remove<td class='argumentdesc'>
<p>(see above)</table><h4>Returns:</h4>
<div class='returnvalue'>
<p>the message for a <em>clear</em> command (see <a href="#*clear">*clear</a>).</div><h4>Discussion:</h4>

<p>Sending the message to the Server will <em>not</em> clear the Client plugin dictionary!</div><h3><a class='anchor' name='Inherited%20class%20methods'>Inherited class methods</a></h3>
<div id='inheritedclassmets'></div><h3><a class='anchor' name='Undocumented%20class%20methods'>Undocumented class methods</a></h3>
<h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*versionBugfix' href='./../Overviews/Methods.html#versionBugfix'>versionBugfix</a></h3>
<h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*versionMajor' href='./../Overviews/Methods.html#versionMajor'>versionMajor</a></h3>
<h3 class='method-code'><span class='method-prefix'>VSTPlugin.</span><a class='method-name' name='*versionMinor' href='./../Overviews/Methods.html#versionMinor'>versionMinor</a></h3>
<h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-id' href='./../Overviews/Methods.html#id'>id</a></h3>
<div class='method'>
<p>the ID which uniquely identifies the plugin in a SynthDef. It should be a Symbol, a Number or <code>nil</code>.</div><h3><a class='anchor' name='Inherited%20instance%20methods'>Inherited instance methods</a></h3>
<div id='inheritedinstmets'></div><h3><a class='anchor' name='Undocumented%20instance%20methods'>Undocumented instance methods</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-info' href='./../Overviews/Methods.html#info'>info</a></h3>
<div class='doclink'>helpfile source: <a href='file:///C:/Users/Christof/AppData/Local/SuperCollider/Extensions/VSTPlugin/HelpSource/Classes/VSTPlugin.schelp'>C:\Users\Christof\AppData\Local\SuperCollider\Extensions\VSTPlugin\HelpSource\Classes\VSTPlugin.schelp</a><br>link::Classes/VSTPlugin::<br></div></div><script src='./../editor.js' type='text/javascript'></script>
</body></html>