TITLE:: VSTPlugin
summary:: load VST plugins as UGens
related:: Classes/VSTPluginController, Classes/VSTPluginGui
categories:: UGens>FX

DESCRIPTION::
note::VST3 plugins are not supported (yet)!::

This UGen represents a single VST plugin instance on the link::Classes/Server::. See the helpfile of link::Classes/VSTPluginController:: for how to control it from the SuperCollider language.

VSTPlugin also has class methods to scan a Server for plugins and cache the info in the Client, see link::#Plugin Management::.

CLASSMETHODS::

PRIVATE:: prGetInfo, prProbeLocal, prProbeRemote, prSearchLocal, prSearchRemote, prResolvePath, prMakeDest, prMakeTmpPath
PRIVATE:: prParseIni, prParseInfo, prGetLine, prParseCount, prParseKeyValuePair, prTrim, kr, platformExtension, reset

METHOD:: ar
create a UGen instance.

ARGUMENT:: input
An Array of channels or single input for the plugin to process. You cannot change the size of this once a SynthDef has been built.
Set this to code::nil:: if the plugin takes no audio input (e.g. software synthesizers).

ARGUMENT:: numOut
The number of output channels. This must be a fixed number greater than 0.

ARGUMENT:: bypass
If this is a non-zero value, the inputs are copied to the outputs, bypassing the plugin. This can be automated.

ARGUMENT:: params
An optional Array of parameter controls in pairs of index and value. Both can be automated.
code::
// 'p1' controls parameter 1. 
// 'p2' controls a parameter whose index can be set dynamically with 'idx'.
SynthDef(\test, { arg in, p1, p2, idx;
	var sig = VSTPlugin.ar(In.ar(in, 2), 1, 
		params: [1, p1, idx, p2]);
	Out.ar(0, sig);
});
::
You can set the index to a negative value to "unmap" the parameter.
note::emphasis::params:: overrides any automation of the same parameters by link::Classes/VSTPluginController#-set:: or
link::Classes/VSTPluginController#-map::.
::
warning::To ensure deterministic results, emphasis::params:: works synchronously (in the realtime thread). 
You are adviced to use it only on parameters which are realtime safe (i.e. don't do any heavy calculations, memory allocations, etc.),
otherwise consider using link::Classes/VSTPluginController#-set::, which works on the non-realtime thread.
::

ARGUMENT:: id
An optional number or symbol which uniquely identifies the UGen within a SynthDef so it can be found by link::Classes/VSTPluginController::.
This is only necessary if there is more than one VSTPlugin instance in the SynthDef!
code::
(
// an EQ and Chorus in parallel:
SynthDef(\test, { arg in, out;
	var sig;
	sig = VSTPlugin.ar(In.ar(in, 2), 2, id: \eq);
	sig = VSTPlugin.ar(sig, 2, id: \chorus);
	Out.ar(out, sig);
}).add;
)
~synth = Synth(\test, [\in, ~in, \out, ~out]); 
(
// this is how you get a handle to a specific plugin instance in the Synth:
~eq = VSTPluginController.new(~synth, \eq);
~chorus = VSTPluginController.new(~synth, \chorus);
)
// load plugins, etc:
~eq.open("...");
~chorus.open("...");
::

ARGUMENT:: info
An optional plugin info Event; the plugin must have been successfully probed (e.g. with link::Classes/VSTPlugin#*search::).

If you know in advance which VST plugin you want to load, this allows you to use parameter names instead of indices
code::
(
SynthDef(\chorus, { arg bus;
	var plugin = VSTPlugin.plugins['GChorus'];
	var sig = VSTPlugin.ar(In.ar(bus, 2), 2, params: [Depth: 0.5, Mix: 0.9], info: plugin);
	ReplaceOut.ar(bus, sig);
}).add;
)
::
Also, you can omit the code::path:: argument when opening plugins:
code::
~fx = VSTPluginController(Synth(\chorus)).open; // will open 'GChorus'
::

SUBSECTION:: Plugin Management

All VST plugin information is cached on the Client. This is done mainly for performance reasons but it can be also handy for end users
because it's possible to investigate plugins without actually creating any instances.

The plugin info is an link::Classes/Event:: with the following entries:
table::
## key || a symbol under which the plugin is stored
## path || the file path
## name || the plugin name
## vendor || the plugin vendor
## category || the plugin category name
## version || the plugin version string
## id || the unique plugin ID (Integer)
## hasEditor || if the plugin has an editor
## numInputs || the number of input channels
## numOutputs || the number of output channels
## singlePrecision || single precision processing supported
## doublePrecision || double precision processing supported
## midiInput || if the plugin receives MIDI messages
## midiOutput || if the plugin sends MIDI messages
## sysexInput || if the plugin receives SysEx messages
## sysexOutput || if the plugin sends SysEx messages
## isSynth || if the plugin is a VST instrument
## numParameters || the number of parameters
## parameterNames || the parameter names as a String Array
## parameterLabels || the parameter labels (e.g. "dB") as a String Array
## numPrograms || the number of programs
## programNames || the default program names as a String Array
::
It also defines the following convenience methods:
table::
## print (long = false) || post the plugin info to the console. 

if emphasis::long:: is code::true::, also list parameters and programs.
## printParameters || post parameter names and labels to the console.
## printPrograms || post default program names to the console
::

note::The info is to be considered read-only!::

The plugin info is stored in an link::Classes/IdentityDictionary:: under its code::key:: and code::path:: 
and can be retrieved with link::#*plugins::.

For VST 2.x plugins, the key is simply the plugin name; for VST 3 plugins, the key has an additional ".vst3" extension
(to distinguish it from a VST 2.x plugin of the same name). It can be used in link::Classes/VSTPluginController#-open::.

SUBSECTION:: Plugin Info

METHOD:: plugins
get information about (probed) VST plugins on a Server.

ARGUMENT:: server
the Server. If this is code::nil::, the default Server is assumed.

RETURNS:: an link::Classes/IdentityDictionary:: containing the info of all VST plugins on the Server.

DISCUSSION::
The dictionary can be simply indexed with the plugin code::key:: or code::path:: (see link::#Plugin Management::). Both must be a symbol.
code::
// search in default paths
VSTPlugin.search(s);
VSTPlugin.plugins(s)['AwesomePlugin'].print;
// for the default server this can be shortend to:
VSTPlugin.search;
VSTPlugin.plugins['AwesomePlugin'].print;
::

METHOD:: pluginList
get all available plugins on a Server.

ARGUMENT:: server
the Server. If code::nil::, the default Server is assumed.

ARGUMENT:: sorted
whether the Array should be sorted alphabetically (by name).

RETURNS:: an Array of plugin info Events.

METHOD:: pluginKeys
get the keys of all plugins on a given Server.

ARGUMENT:: server
the Server. If code::nil::, the default Server is assumed.

RETURNS:: an Array of plugin keys.

DISCUSSION::
This method only considers the keys stored in the plugin info Event,
not the additional keys in the plugin dictionary. 


METHOD:: print
post all available plugins.

ARGUMENT::
the Server. If code::nil::, the default Server is assumed.

DISCUSSION::
The plugins are posted in alphabetical order in the following format:

code::key (vendor) [path]::

SUBSECTION:: Searching for plugins

METHOD:: search
Scan a local or remote Server for VST plugins and cache the info in the Client.

ARGUMENT:: server
The server to scan for plugins. If the argument is code::nil::, the default Server is used.

ARGUMENT:: dir
An optional Array of directories to search. Relative paths are resolved to the currently executing file (must have been saved!).

ARGUMENT:: useDefault
Whether to search in the default paths, which currently are:
table:: 
## Windows || list::
## %ProgramFiles%\VSTPlugins
## %ProgramFiles%\Steinberg\VSTPlugins
## %ProgramFiles%\Common Files\VST2
## %ProgramFiles%\Common Files\Steinberg\VST2
::
## macOS || list::
## /Library/Audio/Plug-Ins/VST
## ~/Library/Audio/Plug-Ins/VST
::
## Linux || list::
## /usr/lib/vst
## /usr/local/lib/vst
::
::

note::here, emphasis::%ProgramFiles%:: stands for "C:\Program Files" on a 64 bit Server and "C:\Program Files (x86)" on a 32 bit Server.::

ARGUMENT:: verbose
a Boolean telling if the Server should post a message for each VST plugin being found.

The message shows the file path, name and probe result. Probing can fail if the file is
not a VST plugin or if it has the wrong architecture (64 bit vs. 32 bit).

ARGUMENT:: wait
The wait time between OSC messages.

-1 allows an OSC roundtrip between packets.

0 is not safe with UDP, but is probably ok with TCP.

note::This is only relevant for remote Servers (local Servers will send the plugin info via temp files).::

ARGUMENT:: action
an action to be called after the search has finished.

ARGUMENT:: save
whether the search results should be written to the cache file.

ARGUMENT:: parallel
whether plugins should be probed in parallel. This can be significantly faster - at the cost of possible audio dropouts (because all CPU cores might be fully utilized).

NOTE::
Shell plugins like "Waves" are always probed in parallel for performance reasons.
::


DISCUSSION::
Directories are searched recursively. For each valid VST plugin, the information is stored in a dictionary on the Client 
and can be retrieved with its key (see link::#Plugin Management::).

If a plugin can't be probed ("... failed!") it either means it's not a valid VST 2.x plugin (VST 3 is not supported yet)
or it has the wrong architecture. 
note::Generally, you can't use 32 bit plugins on a 64 bit Server and vice verca!::

A new search doesn't automatically clear the dictionary, but existing keys are overwritten. 
You can clear the dictionary explicitly with link::#*clear::.

For efficiency, search results are written to a cache file (on the Server's computer) to significantly speed up subsequent searches 
(cached plugins don't have to probed again). Many DAWs use a similar strategy. If you want to search directories without updating the cache, set code::save:: to code::false::.

NOTE::
The very first search in a directory usually takes a couple of seconds, but if you have many (heavy) plugins, the process can take significantly longer. 
However, subsequent searches will be almost instantaneous (because of the cache file).
::

WARNING::
Shell plugins like "Waves" contain hundreds of (heavy) sub-plugins. On my machine, the very first search takes several minutes(!), so be patient :-)
::

METHOD:: searchMsg

ARGUMENT:: dir 
(see above)
ARGUMENT:: useDefault
(see above)
ARGUMENT:: verbose
(see above)
ARGUMENT:: save
(see above)
ARGUMENT:: parallel
(see above)
ARGUMENT:: dest

a) nil: don't write search results (the default)

a) String: name of a temp file where the search results should be written to.

b) link::Classes/Buffer:: or bufnum: the plugin will fill the Buffer
on the Server, the Client can then read the data (each float representing a single byte) and free the Buffer.
The Buffer should be initially empty!

RETURNS:: the message for a emphasis::search:: command (see link::#*search::).

DISCUSSION::

Sending the message to the Server will emphasis::not:: update any info in the Client!
Useful for NRT synthesis.


METHOD:: probe
Probe a single VST plugin.

ARGUMENT:: server
the Server. If code::nil::, the default Server is assumed.

ARGUMENT:: path
the plugin path. Relative paths are resolved to the currently executing file (if saved) or to the standard VST directories
(see link::#*search::).

ARGUMENT:: key
an (optional) additional key under which the plugin info is stored.

ARGUMENT:: wait
the wait time, see link::#*search::.

ARGUMENT:: action
an action to be evaluated after the search has finished.
On success, the plugin info is passed as an link::Classes/Event::, otherwise the argument is code::nil::.

DISCUSSION::

The given plugin file path is probed on the Server (in a seperate process). 
On success, the plugin info is stored under its key, the file path and the (optional) key argument.

This method is used internally by link::Classes/VSTPluginController#-open:: whenever it can't find a key in the plugin dictionary.
It might be occasionally useful for other purposes.


METHOD:: probeMsg

ARGUMENT:: path 
the plugin path (see above)
ARGUMENT:: dest

a) nil: don't write probe result (the default)

a) String: name of a temp file where the probe result should be written to.

b) link::Classes/Buffer:: or bufnum: the plugin will fill the Buffer
on the Server, the Client can then read the data (each float representing a single byte) and free the Buffer.
The Buffer should be initially empty!

RETURNS:: the message for a emphasis::probe:: command (see link::#*probe::).

DISCUSSION::

Sending this message to the Server will emphasis::not:: update any info in the Client!


METHOD:: clear
Deletes all cached plugin info for a given Server.

ARGUMENT:: server
the Server. If this is code::nil::, the default Server is assumed.

ARGUMENT:: remove
whether you want to also remove the cache file.

METHOD:: clearMsg

ARGUMENT:: remove
(see above)

RETURNS:: the message for a emphasis::clear:: command (see link::#*clear::).

DISCUSSION::

Sending the message to the Server will emphasis::not:: clear the Client plugin dictionary!


INSTANCEMETHODS::

METHOD:: id
the ID which uniquely identifies the plugin in a SynthDef. It should be a Symbol, a Number or code::nil::.

